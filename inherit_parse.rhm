#lang shplait
import:
  open:
    "class.rhm"
    "inherit.rhm"

// ----------------------------------------

fun parse_class(s :: Syntax) :: (Symbol * ClassI):
  match s
  | 'final class $name($field, ...):
         extends $parent_name
         $method
         ...':
        values(syntax_to_symbol(name),
               classI(syntax_to_symbol(parent_name),
                      map(parse_field,
                          syntax_to_list('[$field, ...]')),
                      map(parse_method,
                          syntax_to_list('[$method, ...]')), #true))
  | 'class $name($field, ...):
       extends $parent_name
       $method
       ...':
      values(syntax_to_symbol(name),
             classI(syntax_to_symbol(parent_name),
                    map(parse_field,
                        syntax_to_list('[$field, ...]')),
                    map(parse_method,
                        syntax_to_list('[$method, ...]')), #false))
    
  | ~else: error(#'parse_class, "invalid input: " +& s)

fun parse_field(s :: Syntax) :: Symbol:
  cond
  | syntax_is_symbol(s):
      syntax_to_symbol(s)
  | ~else: error(#'parse_field, "invalid input: " +& s)

fun parse_method(s :: Syntax) :: (Symbol * ExpI):
  match s
  |'method $name(arg): $body':
     values(syntax_to_symbol(name),
            parse(body))
  | ~else: error(#'parse_method, "invalid input: " +& s)

fun parse(s :: Syntax) :: ExpI:
  cond
  | syntax_is_integer(s):
      intI(syntax_to_integer(s))
  | ~else:
      match s
      | 'NULL': nullI()
      | 'arg': argI()
      | 'this': thisI()
      | 'if $c == 0 | $bt | $bf':
          if0I(parse(c), parse(bt), parse(bf))
      | '$left + $right':
          plusI(parse(left),
                parse(right))
      | '$left * $right':
          multI(parse(left),
                parse(right))
      | 'new $id($arg, ...)':
          newI(syntax_to_symbol(id),
               map(parse, syntax_to_list('[$arg, ...]')))
      | 'super . $method_name ($arg)':
          superI(syntax_to_symbol(method_name),
                 parse(arg))
      | '$obj . $method_name ($arg)':
          sendI(parse(obj),
                syntax_to_symbol(method_name),
                parse(arg))
          
      | '$obj . $field_name':
          getI(parse(obj),
               syntax_to_symbol(field_name))
      | '($e)':
          parse(e)
      | ~else:
          error(#'parse, "invalid input: " +& s)

module test:
  check: parse('NULL')
         ~is nullI()
  check: parse('if 5 == 0 |6 |7 ')
         ~is if0I(intI(5), intI(6), intI(7))
  check: parse('0')
         ~is intI(0)
  check: parse('arg')
         ~is argI()
  check: parse('this')
         ~is thisI()
  check: parse('1 + 2')
         ~is plusI(intI(1), intI(2))
  check: parse('1 * 2')
         ~is multI(intI(1), intI(2))
  check: parse('new Posn(1, 2)')
         ~is newI(#'Posn, [intI(1), intI(2)])
  check: parse('this.x')
         ~is getI(thisI(), #'x)
  check: parse('this.m(2)')
         ~is sendI(thisI(), #'m, intI(2))
  check: parse('super.m(1)')
         ~is superI(#'m, intI(1))
  check: parse('x')
         ~raises "invalid input"

  check: parse_field('x')
         ~is #'x
  check: parse_field('x 1')
         ~raises "invalid input"

  check: parse_method('method m(arg): this')
         ~is values(#'m, thisI())
  check: parse_method('m(arg): 1 2')
         ~raises "invalid input"
  check: parse_class(' final class Posn3D(x, y, z):
                        extends Posn 
                        method m1(arg): arg
                        method m2(arg): this')
         ~is values(#'Posn3D,
                    classI(#'Posn,
                           [#'x, #'y, #'z],
                           [values(#'m1, argI()),
                            values(#'m2, thisI())], #true))
  check: parse_class('class Posn3D(x, y, z):
                        extends Posn 
                        method m1(arg): arg
                        method m2(arg): this')
         ~is values(#'Posn3D,
                    classI(#'Posn,
                           [#'x, #'y, #'z],
                           [values(#'m1, argI()),
                            values(#'m2, thisI())], #false))
  check: parse_class('class')
         ~raises "invalid input"

// ----------------------------------------

// Interpret a Moe program with inheritance that is
// written with concrete syntax
fun interp_prog(classes :: Listof(Syntax), s :: Syntax) :: Syntax:
  let v = interp_i(parse(s),
                   map(parse_class, classes)):
    match v
    | intV(n): integer_to_syntax(n)
    | objV(class_name, field_vals): 'object'

module test:
  check: interp_prog(
           ['final class Test():
               extends Object
               method do(arg): 5'],
           '(new Test()).do(0)'
         )
         ~is '5'
  check: interp_prog(
           ['class notEmpty():
               extends Object
               method do(arg): 5'],
           '(new notEmpty()).do(5)'
         )
         ~is '5'

  check: interp_prog(
           ['class Posn(x, y):
               extends Object
               method mdist(arg): this.x + this.y
               method addDist(arg): arg.mdist(0) + this.mdist(0)',
            'class Posn3D(z):
               extends Posn
               method mdist(arg): this.z + super.mdist(arg)'],
           '(new Posn3D(5, 3, 1)).addDist(new Posn(2, 7))'
         )
         ~is '18'
  check: interp_prog(
          ['class test1():
              extends Object'],
          '(if 5 == 0 | 6 | 7)'
        )
         ~is '7'
  check: interp_prog(
          ['class test1():
              extends Object'],
          '(if 0 == 0 | 6 | 7)'
        )
         ~is '6'
  check: interp_prog(
          ['class test1():
              extends Object',
           'class test2():
              extends Object'],
          '(if 0 == 0 | new test1() | new test2())'
        )
         ~is 'object'
  check: interp_prog(
          ['class test1():
              extends Object',
           'class test2():
              extends Object'],
          '(if 5 == 0 | new test1() | new test2())'
        )
         ~is 'object'
  check: interp_prog(
          ['class test1():
              extends Object',
           'class test():
              extends Object
              method do(arg): arg'],
          '(new test()).do(NULL)'
              )
         ~is 'object'
  check: interp_prog(
           ['class Posn(x, y):
               extends Object
               method mdist(arg): this.x + this.y
               method addDist(arg): arg.mdist(0) + this.mdist(0)',
            'class Posn3D(z):
               extends Posn
               method mdist(arg): this.z + super.mdist(arg)'],
           '(new Posn3D(5, 3, 1)).addDist(new Posn(2, 7))'
         )
         ~is '18'
         
